
# This file describes compute kernels which are invoked for each step
# Every kernel is run for each step, in the order of appearance in this file top-to-bottom.
# Kernels must declare the name of their OpenCL source code entry function,
# which MUST be of type `void` and accept len(inputs) input attributes of vector data.

[[kernel]]
# The kernel `name` MUST match a kernel defined in the `source` field.
name = "compute_position"

# [colmap] is a dictionary with keys containing
# source arg names and values containing Data column names.
# we get type data by querying parsed source directly and convert from the original to the processing target types.
colmap.id = 'ID'
colmap.x0 = 'X0'
colmap.y0 = 'Y0'

# Constants is a list of keys -> value data.
#   1st element is Name of the variable; this is only used for diagnostic & reporting reasons
#   The 2nd element of the value data is a string denoting type
#   and the 3rd element is a numeric value which will be assigned to that type.
# Constant variables are NOT pointers, and get passed in as their type in the order specified here.
# for that reason, order in this list MUST MATCH ordering in your kernel's `source` function.
data_constants = [
  ['entity_speed_coef', 'float', 5.2 ],
#  ['another_var',   'int64', 999 ],
]

# This string is passed verbatim to the compiler backend.
# Most users will not need these, only those chasing extreme performance will care.
# Option effects are documented at https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_API.html#compiler-options
cl_program_compiler_options = ""

source = '''
kernel void compute_position (
    global float const* id,
    global float* X0,
    global float* Y0,
    float entity_speed_coef
)
{
    const size_t i = get_global_id(0);
    if (i == 0) {
      X0[i] = X0[i] + (entity_speed_coef * 0.1);
      Y0[i] = Y0[i] + (entity_speed_coef * 0.1);
    }
    else {
      //X0[i] = X0[i] - (entity_speed_coef * 0.05);

      // TODO add weight & figure out a momentum calculation

      float x_dist_to_i0 = X0[i] - X0[0];
      float y_dist_to_i0 = Y0[i] - Y0[0];
      X0[i] = X0[i] + (entity_speed_coef * 0.05 * (-x_dist_to_i0 / 100.0));
      Y0[i] = Y0[i] + (entity_speed_coef * 0.05 * (-y_dist_to_i0 / 100.0));
    }
}
'''


